% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tbll_corr.R, R/tbll_desc.R, R/tbll_desc_long.R,
%   R/tbll_item_analysis.R
\name{Tbll_corr}
\alias{Tbll_corr}
\alias{Tbll_desc}
\alias{Tbll_desc_multi}
\alias{Tbll_mean}
\alias{Tbll_desc_long}
\alias{Tbll_desc_item}
\title{Tbll_desc}
\usage{
Tbll_corr(
  ...,
  include.label = TRUE,
  include.mean = FALSE,
  include.n = TRUE,
  include.stars = TRUE,
  include.p = FALSE,
  cor_diagonale_up = TRUE,
  type = c("pearson", "spearman")
)

Tbll_desc(
  ...,
  include.label = TRUE,
  include.n = TRUE,
  include.nr = FALSE,
  include.total = FALSE,
  include.test = FALSE,
  include.normality.tests = FALSE,
  include.multiresponse = FALSE,
  include.custom = NULL,
  include.value = NULL,
  include.measure = NULL,
  digits = NULL,
  use.level = 1,
  use.duplicated = FALSE
)

Tbll_desc_multi(
  ...,
  by = NULL,
  digits = 0,
  include.order = TRUE,
  exclude.last.order = FALSE,
  use.level = 1,
  include.label = TRUE,
  include.n = TRUE,
  include.nr = FALSE,
  include.total = FALSE,
  include.test = FALSE,
  include.normality.tests = FALSE,
  include.custom = NULL,
  include.value = NULL
)

Tbll_mean(
  ...,
  include.total = TRUE,
  include.custom = function(x) {
     round(c(n = length(na.omit(x)), mean = mean(x,
    na.rm = TRUE), sd = sd(x, na.rm = TRUE)), 2)
 }
)

Tbll_desc_long(
  ...,
  include.range = TRUE,
  include.n = TRUE,
  include.label = TRUE,
  include.custom = NULL,
  digits = NULL,
  abbreviate = TRUE
)

Tbll_desc_item(
  ...,
  include.label = FALSE,
  include.n = TRUE,
  include.mean = TRUE,
  include.median = FALSE,
  include.sd = TRUE,
  include.range = TRUE,
  include.shapiro = TRUE,
  include.ks = FALSE,
  include.skew = TRUE,
  include.kurtosi = include.skew,
  digits = 2
)
}
\arguments{
\item{...}{an prepare_data2}

\item{include.label}{logical. Labels ja-nein}

\item{include.mean, include.median, include.sd}{Masszahlen}

\item{include.n}{logical. Anzahl an gueltigen Werten (je Zeile)}

\item{include.stars, include.p}{Tbll_corr(): P-Werte,Explizite p-Werte, Sternchen als p-Werte}

\item{cor_diagonale_up}{Tbll_corr(): Diagonale oben oder unter}

\item{type}{Tbll_corr(): enweder "pearson" oder "spearman"}

\item{include.nr}{logical or numeric.
Anzahl an gueltigen Werten aber in der ersten Zeile.
Spezialtrick: wenn alle Items die gleichen Fehlenden Werte besiten dann -> include.n=FALSE, include.nr=TRUE, na.action = na.omit}

\item{include.total, include.multiresponse}{logical. weitere param}

\item{include.test, include.normality.tests}{logical or character. wilcoxon, anova, t.test}

\item{include.custom}{function. Funktion mit (x, by, fun) return kann ein Vector oder eine Matrix sein.

Tbll_desc(...,
  function(x , by, ...) \{

    x <- scale(as.numeric(x))

    diff( sapply( split(x, by), mean, na.rm=TRUE ) )

    \}
    )

 in Tbll_Mean(..., include.custom  =  function(x) Auswertung (x) )

 in Tbll_desc_long(..., include.custom = function(x) \{ mean(x) \})}

\item{include.value}{vector oder data.frame in exact der Reihenfolge wie die meassure-variablen.}

\item{include.measure}{character, für alle z.B. dem Median verwenden}

\item{digits}{Nachkommastellen}

\item{use.level, include.order, exclude.last.order}{Tbll_desc_multi weitere einstellungen}

\item{use.duplicated}{logical. erlaube duplikate der Messwerte}

\item{by}{Gruppenvariable}

\item{include.range}{in Tbll_desc_long()}

\item{abbreviate}{Tbll_desc_long}

\item{include.shapiro, include.ks}{Normalverteilung Tests}

\item{include.skew, include.kurtosi}{Eigenschaften}
}
\value{
data.frame
}
\description{
Simple and intuitive formula and pipe-based framework for performing basic statistical Tabels.

Tbll_desc_multi: ruft direkt Tbll_desc auf
mit unterschiedlichen Parametern (include.multiresponse = TRUE)

Tbll_mean() ist in Begleitung einer Regression gedacht bei der mit
include.custom = fun die Masszahlen berechnet werden.

Tbll_desc_long
}
\examples{


 \donttest{
# install.packages("corrr")
require(corrr)
require(stp25stat2)
require(stp25tools)
set.seed(1)
n <- 2 * 20
x <- rnorm(n)
y <- rnorm(n)

dat <-
  data.frame(
    group = gl(2, 20, labels = c("Control", "Treat")),
    a = rnorm(n,0,1),
    b =  x,
    c =  y,
    d = rnorm(n,0,.5) + x + y,
    e = rnorm(n,0,.5) + x - y,
    f = rnorm(n,0,.5) - x + y,
    g = rnorm(n,0,.75)  + x,
    h = rnorm(n,0,.5) - y
  ) |> Label(
    a = "Alpha",
    b = "Beta",
    c = "Gamma"
  )


Tbll_corr( ~ a + b + c, dat)
Tbll_corr(a ~ c, dat)
Tbll_corr(a + b + c ~ d, dat)
Tbll_corr(a + b + c ~ d, dat, groups = ~ group)

x<-corrr::correlate(dat[-1])
x
#corrr::fashion(x)
#corrr::rplot(x)
corrr::network_plot(x, min_cor = .2)

}

n<- 100
set.seed(1)
DF <- data.frame(
  sex= gl(2, n/3, labels = c("male", "female"))[sample.int(n)],
  group = gl(2, n/3, labels = c("Control", "Treat"))[sample.int(n)],
  age= runif(n, min = 18, max = 73)

)

DF<- na.omit(DF)

set_opt(
  median = list(digits = 0, style=2),
  prozent = list(style=2, null_percent_sign =  ' . ')
)


DF |>
  Tbll_desc( sex[ratio],
             group[freq],
             age[median],
             by= ~group,
             include.total=TRUE)

 # in der Formula koennen auch eigene Funkrtionen mit dem Namen fun oder funny
 # uebergeben werden. Die Einstellung use.duplicated geht aber nicht.
 #
 # Prototyp für einene Function
#'  funny <-
fun <-
  function(x,
           digits = get_opt("mean", "digits"),
           n = length(x)) {
    data.frame(
      lev = c("Coustom Fun",
              "   mean",
              "   sd"),
      n = c(as.character(n), "", ""),
      m = c("",
            round(mean(x, na.rm = TRUE), digits),
            round(sd(x, na.rm = TRUE), digits)),
      stringsAsFactors = FALSE
    )
  }

DF |>
  Tbll_desc( age[fun],
             by= ~group,
             include.total=TRUE)

Tbll_desc(
  warpbreaks,
  "H1",
  breaks,
  tension,
  by = ~ wool,
  include.total = TRUE,
  include.n = FALSE,
  include.test = TRUE
)

\donttest{
warpbreaks2 <- stp25tools::Label(warpbreaks,
                     breaks	=	"The number of breaks",
                     wool	=	"The type of wool",
                     tension	=	"The level of tension")
warpbreaks2$tension2 <- as.numeric(warpbreaks2$tension)

warpbreaks2 |>
  Tbll_desc(breaks + tension ~ wool)
warpbreaks2 |>
  Tbll_desc_long(breaks + tension ~ wool)



Tbll_desc(
  warpbreaks,
  # "H1",
  breaks,
  tension,
  by = ~ wool,
  #  include.total = TRUE,
  # include.n = FALSE,
  include.test = TRUE,
  include.value = c(breaks = "ES = 26", tension = "OR = .0256")

)

x <- Tbll_desc(
  warpbreaks,
  # "H1",
  breaks,
  tension,
  by = ~ wool,
  include.total = TRUE,
  # include.n = FALSE,
  include.test = TRUE,
  include.value = data.frame(ES = 1:2, OR = 3:4)

)


Tbll_xtabs( ~ tension + wool, warpbreaks2, include.label = FALSE)

lm1 <- lm(breaks ~ wool + tension, data = warpbreaks2)
lm2 <- lm(breaks ~ wool * tension, data = warpbreaks2)


Tbll_reg(
  lm1,
  lm2,
  include.p = FALSE,
  include.ci = TRUE,
  include.se = FALSE
)


Tbll_reg(lm1, lm2)

 }

#  Tbll_desc_multi()

dat <- data.frame(
  Campingplatz = c(0, 0, 0, 1, 0, 1, 1, 0, 0, 0, NA),
  Pension = c(1, 1, 0, 0, 0, 1, 1, 1, 1, 1, NA),
  Hotel =  c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA),
  Ferienwohnung = c(1, 1, 1, 1, 0, 0, 0, 1, 0, 0, NA),
  Airbnb = c(0, 0, 0, 0, 0, 1, 0, 1, 1, 1, NA),
  Hostel = c(1, 1, 0, 1, 1, 0, 0, 1, 0, 1, NA),
  Couchsurfing = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, NA)
)


nrow(dat)
dat |>
  Tbll_desc_multi(
    Campingplatz,
    Pension,
    Hotel,
    Ferienwohnung,
    Airbnb,
    Hostel,
    Couchsurfing,
    #Workaround für Fehene Werte
    include.n = FALSE,
    include.nr = TRUE,
    na.action = na.omit
  )

# # stp25plot::multi_barplot(dat)
# require(stp25likert)
#
# dat |>
#   Summarise_multi(
#     Campingplatz,
#     Pension,
#     Hotel,
#     Ferienwohnung,
#     Airbnb,
#     Hostel,
#     Couchsurfing) #|> likert_stacked()


DF <- data.frame(group = gl(2, 10, 20, labels = c("Ctl", "Trt")),
sex =  factor(c(1, 1, 1, 1, 1, 2, 1, 1, 1, 1,
                2, 1, 2, 2, 2, 1, 2, 1, 2, 1), 1:2, c("m", "f")),
weight = c(
  4.17, 5.58, 5.18, 6.11, 4.50,
  4.61, 5.17, 4.53, 5.33, 5.14,
  4.81, 4.17, 4.41, 3.59, 5.87,
  3.83, 6.03, 4.89, 4.32, 4.69
))
lm.D9 <- lm(weight ~ group + sex, DF)

Tbll_mean(weight ~ group + sex, DF)
#Tbll_desc(weight ~ group, DF)
Tbll_effect(lm.D9)
#Tbll (lm.D9)
#Tbll_model( lm.D9 )


# from Hmisc
# summary(breaks ~ tension + wool, warpbreaks)
Tbll_mean(breaks ~ tension + wool, warpbreaks)

Tbll_mean(
   breaks ~ tension + wool,
   warpbreaks,
   include.custom = Median_ci

)



#mtcars |> Tbll_desc(mpg, cyl,  disp,  hp, drat,
#                    wt,  qsec, vs, am, gear, carb)
mtcars |> Tbll_desc_long(
  mpg[mean, 1],
  cyl[median],
  "Hallo",
  disp[0],
  hp[0],
  drat,
  wt,
  qsec[1],
  vs[freq],
  am[freq],
  gear,
  carb,
  include.range = TRUE,
  include.n = TRUE
)

mtcars |> Tbll_desc_long(
mpg,
cyl,
drat,
wt,
gear,
carb,
# by=~gear,

include.custom = function(x, by, ...){
  x <- as.numeric(x)
  c(mean= mean(x, na.rm=TRUE), sd=sd(x))
}

)


\donttest{

mtcars$G <- factor(mtcars$vs, 0:1, c("A", "B"))

mtcars <- stp25tools::Label(
  mtcars,
  mpg	= "Miles/(US) gallon",
  cyl	= "Number of cylinders",
  disp =	"Displacement (cu.in.)",
  hp	= "Gross horsepower",
  drat =	"Rear axle ratio",
  wt	= "Weight (1000 lbs)",
  qsec =	"1/4 mile time",
  vs	= "Engine (0 = V-shaped, 1 = straight)",
  am	= "Transmission (0 = automatic, 1 = manual)",
  gear =	"Number of forward gears",
  carb =	"Number of carburetors"
)

mtcars |> Tbll_desc_long(
  mpg[mean, 1],
  cyl[median],
  "Hallo",
  disp[0],
  hp[0],
  drat,
  wt,
  qsec[1],
  vs[freq],
  am[freq],
  gear,
  carb,
  by =  ~ G,
  include.range = TRUE,
  include.n = TRUE,
  include.label=FALSE
)

}


df <- data.frame(
  A = c(1,2,3,4,5, 1,1,1,2, 1,1,1,5,5,5),
  B = c(1,2,3,4,5, 2,2,2,1, 1,1,1,5,5,5),
  C = c(1,2,3,4,5, 3,3,3,4, 1,1,1,5,5,5),
  D = c(1,2,3,5,5, 4,5,4,5, 1,1,1,5,5,5),
  E = c(1,2,3,4,5, 3,2,1,1, 1,1,1,5,5,5)
)

# Tbll_desc_item(  ~ A + B + C + D + E, df)

Tbll_reliability(~ A + B + C + D + E, df,
                 include.item_statistics = TRUE)

#  df$index <-scale( rowSums(df) )
#  Tbll_item_analysis(  A + B + C + D + E ~ index, df)

}
